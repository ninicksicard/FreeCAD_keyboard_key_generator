"""
batch_keycaps_export_stl_ui.FCMacro

Batch-generate per-key STL files from a selected blank key object in the current document.

Features:
- UI: pick template object, face (top/front/right/left/back/bottom), font, output folder, engrave/raise, size, depth, offsets.
- Fonts: scans common Linux font directories; variable fonts filtered by default.
- Placement: legend is placed on the selected face using the face plane coordinate system (fixes "wrong face" issues).
- Preview: creates/updates a single temporary preview object in the document.
- Export: writes STL using mesh.write().
"""

from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Dict, List, Tuple

import FreeCAD as App

try:
    import FreeCADGui as Gui  # type: ignore
except Exception as exc:
    raise RuntimeError("This macro requires the FreeCAD GUI (cannot run headless).") from exc

import Mesh
import Part

try:
    import Draft  # type: ignore
except Exception as exc:
    raise RuntimeError("Draft module is required (ShapeString).") from exc

try:
    from PySide2 import QtWidgets  # type: ignore
except Exception as exc:
    raise RuntimeError("PySide2 is required (Qt GUI).") from exc


# -----------------------------
# Keys to export (edit this list)
# -----------------------------
# (label_to_render, filename_safe)
KEYS: List[Tuple[str, str]] = [
    ("ESC", "ESC"),
    ("1", "1"),
    ("2", "2"),
    ("3", "3"),
    ("Q", "Q"),
    ("W", "W"),
    ("E", "E"),
    ("A", "A"),
    ("S", "S"),
    ("D", "D"),
    ("Z", "Z"),
    ("X", "X"),
    ("C", "C"),
    ("SPACE", "SPACE"),
]


# -----------------------------
# Font scanning
# -----------------------------

DEFAULT_FONT_DIRS: List[str] = [
    "/usr/share/fonts",
    "/usr/local/share/fonts",
    os.path.expanduser("~/.local/share/fonts"),
    os.path.expanduser("~/.fonts"),
]


def _is_variable_font_filename(font_path: str) -> bool:
    base = os.path.basename(font_path).lower()
    return "variablefont" in base or "variable-font" in base


def _scan_ttf_otf_files(font_dirs: List[str], include_variable_fonts: bool) -> List[str]:
    font_paths: List[str] = []
    for root_dir in font_dirs:
        if not os.path.isdir(root_dir):
            continue
        for dirpath, _, filenames in os.walk(root_dir):
            for filename in filenames:
                lower_name = filename.lower()
                if not (lower_name.endswith(".ttf") or lower_name.endswith(".otf")):
                    continue
                full_path = os.path.join(dirpath, filename)
                if (not include_variable_fonts) and _is_variable_font_filename(full_path):
                    continue
                font_paths.append(full_path)

    return sorted(set(font_paths), key=lambda p: p.lower())


def _font_display_name(font_path: str) -> str:
    return os.path.basename(font_path)


# -----------------------------
# Template object discovery
# -----------------------------

def _list_solid_objects(doc: App.Document) -> List[App.DocumentObject]:
    result: List[App.DocumentObject] = []
    for obj in doc.Objects:
        if not hasattr(obj, "Shape"):
            continue
        try:
            shape = obj.Shape
        except Exception:
            continue
        if shape is None or shape.isNull():
            continue
        if len(shape.Solids) <= 0:
            continue
        result.append(obj)
    return result


def _object_display_name(obj: App.DocumentObject) -> str:
    label = getattr(obj, "Label", "") or ""
    name = getattr(obj, "Name", "") or ""
    if label and name and label != name:
        return f"{label} ({name})"
    return label or name or "UnnamedObject"


def _resolve_object_by_name(doc: App.Document, name: str) -> App.DocumentObject:
    obj = doc.getObject(name)
    if obj is None:
        raise ValueError(f"Selected template object not found: {name}")
    return obj


# -----------------------------
# Face selection by direction
# -----------------------------

FACE_DIRECTIONS: Dict[str, App.Vector] = {
    "Top (+Z)": App.Vector(0.0, 0.0, 1.0),
    "Bottom (-Z)": App.Vector(0.0, 0.0, -1.0),
    "Front (+Y)": App.Vector(0.0, 1.0, 0.0),
    "Back (-Y)": App.Vector(0.0, -1.0, 0.0),
    "Right (+X)": App.Vector(1.0, 0.0, 0.0),
    "Left (-X)": App.Vector(-1.0, 0.0, 0.0),
}


def _unit_vector(v: App.Vector) -> App.Vector:
    if v.Length == 0.0:
        raise ValueError("Zero-length vector.")
    return v.multiply(1.0 / v.Length)


def _best_face_for_direction(solid_shape: Part.Shape, direction_world: App.Vector) -> Part.Face:
    """
    Pick the face whose normal best matches direction_world.
    Uses face normal at face center.
    """
    direction = _unit_vector(direction_world)

    best_face: Part.Face | None = None
    best_score = -1.0
    best_support = -1e100

    # Also bias toward faces that are "outermost" in that direction
    # (by dot(center, direction))
    for face in solid_shape.Faces:
        try:
            u_mid = 0.5 * (face.ParameterRange[0] + face.ParameterRange[1])
            v_mid = 0.5 * (face.ParameterRange[2] + face.ParameterRange[3])
            normal = face.normalAt(u_mid, v_mid)
        except Exception:
            # If normalAt fails, skip
            continue

        n = _unit_vector(App.Vector(normal.x, normal.y, normal.z))
        score = n.dot(direction)
        if score < best_score:
            continue

        center = face.CenterOfMass
        support = App.Vector(center.x, center.y, center.z).dot(direction)

        # Prefer higher alignment first, then outermost
        if (score > best_score + 1e-6) or (abs(score - best_score) <= 1e-6 and support > best_support):
            best_face = face
            best_score = score
            best_support = support

    if best_face is None:
        raise RuntimeError("Could not determine a suitable face for the selected direction.")
    return best_face


def _make_face_plane_placement(face: Part.Face) -> Tuple[App.Placement, App.Vector]:
    """
    Build a local coordinate system for the face:
    - origin at face center of mass
    - Z axis = face normal
    - X/Y axes = arbitrary but stable basis on the face plane
    Returns:
    - placement mapping local -> world
    - face_normal (world unit)
    """
    center = face.CenterOfMass
    u_mid = 0.5 * (face.ParameterRange[0] + face.ParameterRange[1])
    v_mid = 0.5 * (face.ParameterRange[2] + face.ParameterRange[3])
    normal = face.normalAt(u_mid, v_mid)
    n = _unit_vector(App.Vector(normal.x, normal.y, normal.z))

    # Choose an "up" that is not parallel to n
    up = App.Vector(0.0, 0.0, 1.0)
    if abs(n.dot(up)) > 0.95:
        up = App.Vector(0.0, 1.0, 0.0)

    x_axis = _unit_vector(up.cross(n))
    y_axis = _unit_vector(n.cross(x_axis))

    rot = App.Rotation(x_axis, y_axis, n)
    placement = App.Placement(App.Vector(center.x, center.y, center.z), rot)
    return placement, n


# -----------------------------
# Geometry helpers
# -----------------------------

def _make_shapestring_shape(doc: App.Document, label: str, font_path: str, size_mm: float) -> Part.Shape:
    shapestring_obj = Draft.makeShapeString(String=label, FontFile=font_path, Size=size_mm)
    shapestring_obj.Label = f"tmp_shapestring_{label}"
    doc.recompute()

    shape = shapestring_obj.Shape.copy()
    doc.removeObject(shapestring_obj.Name)
    doc.recompute()
    return shape


def _extrude_to_solid(shape: Part.Shape, height_mm: float) -> Part.Shape:
    if height_mm <= 0.0:
        raise ValueError("Legend height/depth must be > 0.")

    if shape.ShapeType == "Wire":
        shape = Part.Face(shape)
    elif shape.ShapeType == "Compound":
        if len(shape.Faces) == 0 and len(shape.Wires) > 0:
            faces = []
            for wire in shape.Wires:
                faces.append(Part.Face(wire))
            shape = Part.makeCompound(faces)

    return shape.extrude(App.Vector(0.0, 0.0, height_mm))


def _shape_to_mesh(shape: Part.Shape, linear_deflection: float) -> "Mesh.Mesh":
    if linear_deflection <= 0.0:
        raise ValueError("Linear deflection must be > 0.")
    mesh = Mesh.Mesh()
    triangles = shape.tessellate(linear_deflection)
    mesh.addFacets(triangles)
    return mesh


def _export_stl(mesh: "Mesh.Mesh", filepath: str) -> None:
    mesh.write(filepath)


def _remove_existing_preview(doc: App.Document) -> None:
    obj = doc.getObject("__KEYCAP_PREVIEW__")
    if obj is not None:
        doc.removeObject(obj.Name)
        doc.recompute()


def _set_preview_shape(doc: App.Document, shape: Part.Shape) -> None:
    obj = doc.getObject("__KEYCAP_PREVIEW__")
    if obj is None:
        obj = doc.addObject("Part::Feature", "__KEYCAP_PREVIEW__")
        obj.Label = "__KEYCAP_PREVIEW__"
    obj.Shape = shape
    doc.recompute()


# -----------------------------
# Config + UI
# -----------------------------

@dataclass(frozen=True)
class ExportConfig:
    template_object_name: str
    face_choice_label: str
    font_path: str
    output_dir: str
    mode: str  # "engrave" or "raise"
    size_mm: float
    depth_mm: float
    offset_x_mm: float
    offset_y_mm: float
    linear_deflection: float
    preview_label: str


class BatchKeycapDialog(QtWidgets.QDialog):
    def __init__(self, doc: App.Document) -> None:
        super().__init__(Gui.getMainWindow())
        self.setWindowTitle("Batch Keycap STL Export")

        self._doc = doc

        # Template objects: solids only
        self._solid_objects = _list_solid_objects(doc)

        self.template_combo = QtWidgets.QComboBox()
        self._template_name_by_index: Dict[int, str] = {}
        for index, obj in enumerate(self._solid_objects):
            self.template_combo.addItem(_object_display_name(obj))
            self._template_name_by_index[index] = obj.Name

        # Face selector
        self.face_combo = QtWidgets.QComboBox()
        for face_label in FACE_DIRECTIONS.keys():
            self.face_combo.addItem(face_label)

        # Fonts
        self.include_variable_fonts_checkbox = QtWidgets.QCheckBox("Include variable fonts")
        self.include_variable_fonts_checkbox.setChecked(False)
        self.include_variable_fonts_checkbox.stateChanged.connect(self._reload_fonts)

        self.font_combo = QtWidgets.QComboBox()
        self._font_paths: List[str] = []
        self._font_path_by_index: Dict[int, str] = {}

        self.font_browse_btn = QtWidgets.QPushButton("Browse...")
        self.font_browse_btn.clicked.connect(self._browse_font)

        self.output_dir_edit = QtWidgets.QLineEdit(os.path.expanduser("~/keycaps_stl_out"))
        self.output_browse_btn = QtWidgets.QPushButton("Browse...")
        self.output_browse_btn.clicked.connect(self._browse_output_dir)

        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.addItems(["engrave", "raise"])

        self.size_spin = QtWidgets.QDoubleSpinBox()
        self.size_spin.setRange(1.0, 50.0)
        self.size_spin.setDecimals(2)
        self.size_spin.setValue(6.0)

        self.depth_spin = QtWidgets.QDoubleSpinBox()
        self.depth_spin.setRange(0.05, 10.0)
        self.depth_spin.setDecimals(2)
        self.depth_spin.setValue(0.6)

        self.offset_x_spin = QtWidgets.QDoubleSpinBox()
        self.offset_x_spin.setRange(-50.0, 50.0)
        self.offset_x_spin.setDecimals(2)
        self.offset_x_spin.setValue(0.0)

        self.offset_y_spin = QtWidgets.QDoubleSpinBox()
        self.offset_y_spin.setRange(-50.0, 50.0)
        self.offset_y_spin.setDecimals(2)
        self.offset_y_spin.setValue(0.0)

        self.linear_defl_spin = QtWidgets.QDoubleSpinBox()
        self.linear_defl_spin.setRange(0.01, 2.0)
        self.linear_defl_spin.setDecimals(3)
        self.linear_defl_spin.setValue(0.08)

        # Preview controls
        self.preview_label_edit = QtWidgets.QLineEdit("A")
        self.preview_update_btn = QtWidgets.QPushButton("Update Preview")
        self.preview_clear_btn = QtWidgets.QPushButton("Clear Preview")

        self.preview_update_btn.clicked.connect(self._update_preview_clicked)
        self.preview_clear_btn.clicked.connect(self._clear_preview_clicked)

        self._reload_fonts()

        # Layout
        form = QtWidgets.QFormLayout()

        if len(self._solid_objects) == 0:
            warning = QtWidgets.QLabel("No solid template objects found in this document (need Shape with Solids).")
            warning.setStyleSheet("color: #cc0000;")
            form.addRow("Template:", warning)
        else:
            form.addRow("Template object:", self.template_combo)

        form.addRow("Legend face:", self.face_combo)

        font_row = QtWidgets.QHBoxLayout()
        font_row.addWidget(self.font_combo)
        font_row.addWidget(self.font_browse_btn)
        form.addRow("Font:", font_row)
        form.addRow("", self.include_variable_fonts_checkbox)

        out_row = QtWidgets.QHBoxLayout()
        out_row.addWidget(self.output_dir_edit)
        out_row.addWidget(self.output_browse_btn)
        form.addRow("Output folder:", out_row)

        form.addRow("Legend mode:", self.mode_combo)
        form.addRow("Font size (mm):", self.size_spin)
        form.addRow("Depth/height (mm):", self.depth_spin)
        form.addRow("Legend offset X (mm):", self.offset_x_spin)
        form.addRow("Legend offset Y (mm):", self.offset_y_spin)
        form.addRow("Mesh linear deflection:", self.linear_defl_spin)

        preview_row = QtWidgets.QHBoxLayout()
        preview_row.addWidget(QtWidgets.QLabel("Label:"))
        preview_row.addWidget(self.preview_label_edit)
        preview_row.addWidget(self.preview_update_btn)
        preview_row.addWidget(self.preview_clear_btn)
        form.addRow("Preview:", preview_row)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout = QtWidgets.QVBoxLayout()
        layout.addLayout(form)
        layout.addWidget(buttons)
        self.setLayout(layout)

        self.resize(820, 0)

    def _reload_fonts(self) -> None:
        include_variable = bool(self.include_variable_fonts_checkbox.isChecked())
        self._font_paths = _scan_ttf_otf_files(DEFAULT_FONT_DIRS, include_variable_fonts=include_variable)

        self.font_combo.clear()
        self._font_path_by_index.clear()
        for index, font_path in enumerate(self._font_paths):
            self.font_combo.addItem(_font_display_name(font_path))
            self._font_path_by_index[index] = font_path

    def _browse_font(self) -> None:
        start_dir = "/usr/share/fonts" if os.path.isdir("/usr/share/fonts") else os.path.expanduser("~")
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select font", start_dir, "Fonts (*.ttf *.otf)")
        if not path:
            return

        if (not self.include_variable_fonts_checkbox.isChecked()) and _is_variable_font_filename(path):
            App.Console.PrintMessage(
                "Warning: variable font selected; Draft ShapeString may fail. "
                "If it fails, pick a non-variable TTF/OTF.\n"
            )

        if path not in self._font_paths:
            self._font_paths.append(path)
            self._font_paths = sorted(set(self._font_paths), key=lambda p: p.lower())
            self.font_combo.clear()
            self._font_path_by_index.clear()
            for index, font_path in enumerate(self._font_paths):
                self.font_combo.addItem(_font_display_name(font_path))
                self._font_path_by_index[index] = font_path

        for index in range(self.font_combo.count()):
            if self._font_path_by_index.get(index) == path:
                self.font_combo.setCurrentIndex(index)
                break

    def _browse_output_dir(self) -> None:
        start_dir = self.output_dir_edit.text().strip() or os.path.expanduser("~")
        path = QtWidgets.QFileDialog.getExistingDirectory(self, "Select output folder", start_dir)
        if path:
            self.output_dir_edit.setText(path)

    def _get_config_for_preview(self) -> ExportConfig:
        if len(self._solid_objects) == 0:
            raise RuntimeError("No solid template object available. Use a Body/feature that produces a solid.")

        template_index = int(self.template_combo.currentIndex())
        template_name = self._template_name_by_index.get(template_index, "")

        font_index = int(self.font_combo.currentIndex())
        font_path = self._font_path_by_index.get(font_index, "")

        return ExportConfig(
            template_object_name=template_name,
            face_choice_label=self.face_combo.currentText().strip(),
            font_path=font_path,
            output_dir=self.output_dir_edit.text().strip(),
            mode=self.mode_combo.currentText().strip().lower(),
            size_mm=float(self.size_spin.value()),
            depth_mm=float(self.depth_spin.value()),
            offset_x_mm=float(self.offset_x_spin.value()),
            offset_y_mm=float(self.offset_y_spin.value()),
            linear_deflection=float(self.linear_defl_spin.value()),
            preview_label=self.preview_label_edit.text().strip() or "A",
        )

    def _update_preview_clicked(self) -> None:
        cfg = self._get_config_for_preview()
        try:
            preview_shape = _build_keycap_with_legend_shape(
                doc=self._doc,
                cfg=cfg,
                label=cfg.preview_label,
            )
            _set_preview_shape(self._doc, preview_shape)
            Gui.ActiveDocument.ActiveView.fitAll()
        except Exception as exc:
            App.Console.PrintError(f"Preview failed: {exc}\n")

    def _clear_preview_clicked(self) -> None:
        _remove_existing_preview(self._doc)

    def get_config(self) -> ExportConfig:
        return self._get_config_for_preview()


# -----------------------------
# Core build function used by preview + export
# -----------------------------

def _build_keycap_with_legend_shape(doc: App.Document, cfg: ExportConfig, label: str) -> Part.Shape:
    template_obj = _resolve_object_by_name(doc, cfg.template_object_name)
    template_shape = template_obj.Shape.copy()
    if template_shape.isNull() or len(template_shape.Solids) <= 0:
        raise RuntimeError("Template object does not contain a solid. Pick a Body/feature that is the final solid.")

    direction = FACE_DIRECTIONS.get(cfg.face_choice_label)
    if direction is None:
        raise ValueError(f"Unknown face choice: {cfg.face_choice_label}")

    face = _best_face_for_direction(template_shape, direction_world=direction)
    face_placement, face_normal = _make_face_plane_placement(face)

    # Build legend shape in its own local coordinates near origin
    legend_shape = _make_shapestring_shape(doc, label, cfg.font_path, cfg.size_mm)

    # Center legend in its own bbox first (so offsets are intuitive)
    legend_bbox = legend_shape.BoundBox
    legend_center_x = (legend_bbox.XMin + legend_bbox.XMax) * 0.5
    legend_center_y = (legend_bbox.YMin + legend_bbox.YMax) * 0.5

    legend_shape.translate(App.Vector(-legend_center_x, -legend_center_y, 0.0))
    legend_shape.translate(App.Vector(cfg.offset_x_mm, cfg.offset_y_mm, 0.0))

    # Place legend onto the face plane (local Z is face normal)
    # Slight overlap to ensure boolean works (0.05mm)
    overlap = 0.05
    legend_shape.translate(App.Vector(0.0, 0.0, -overlap))
    legend_shape.Placement = face_placement.multiply(legend_shape.Placement)

    legend_solid = _extrude_to_solid(legend_shape, cfg.depth_mm)

    blank_key = template_shape.copy()

    if cfg.mode == "raise":
        final_solid = blank_key.fuse(legend_solid)
    elif cfg.mode == "engrave":
        final_solid = blank_key.cut(legend_solid)
    else:
        raise ValueError('Legend mode must be "engrave" or "raise".')

    return final_solid


# -----------------------------
# Export logic
# -----------------------------

def generate_keycaps_to_stl_from_selected_template(keys: List[Tuple[str, str]]) -> None:
    doc = App.ActiveDocument
    if doc is None:
        raise RuntimeError("No active document. Open your blank key document first.")

    dialog = BatchKeycapDialog(doc)
    if dialog.exec_() != QtWidgets.QDialog.Accepted:
        App.Console.PrintMessage("Canceled.\n")
        return

    cfg = dialog.get_config()

    if not cfg.font_path or not os.path.isfile(cfg.font_path):
        raise FileNotFoundError(f"Font file not found: {cfg.font_path}")

    if not cfg.output_dir:
        raise ValueError("Output folder is empty.")
    os.makedirs(cfg.output_dir, exist_ok=True)

    App.Console.PrintMessage(f"Template: {cfg.template_object_name}\n")
    App.Console.PrintMessage(f"Face: {cfg.face_choice_label}\n")
    App.Console.PrintMessage(f"Font: {cfg.font_path}\n")
    App.Console.PrintMessage(f"Output: {cfg.output_dir}\n")

    for label, safe_name in keys:
        final_solid = _build_keycap_with_legend_shape(doc, cfg, label=label)
        mesh = _shape_to_mesh(final_solid, cfg.linear_deflection)
        out_path = os.path.join(cfg.output_dir, f"{safe_name}.stl")
        _export_stl(mesh, out_path)
        App.Console.PrintMessage(f"Exported: {out_path}\n")

    # Optional: clear preview after export
    # _remove_existing_preview(doc)

    App.Console.PrintMessage("Done.\n")


generate_keycaps_to_stl_from_selected_template(KEYS)
